{"version":3,"sources":["types.ts","functions/GraphFunctions.ts","algos/depthFirstSearch.ts","components/GraphNode.tsx","components/Graph.tsx","components/OptionsBar.tsx","algos/breadthFirstSearch.ts","components/Dashboard.tsx","App.tsx","index.tsx"],"names":["graphTypes","GraphUnitTypes","AlgoTypes","hasNodeNotBeenQueued","Graph","MarkingNodeCords","queued","nodeIsNotEmptySpace","X","Y","type","EMPTY_SPACE","findAdjancentNonQueuedNodes","Node","Height","Width","callbackCheck","TopNodeCords","BottomNodeCords","RightNodeCords","LeftNodeCords","AdjancentNodes","push","length","ChangeGraphUnitType","Xcord","Ycord","SetGraph","TypeToChange","deleteEdges","replacePreviousEdge","prevGraph","dup","START","FINISH","prevNode","previous","LEFT_RIGHT_EDGE","UP_DOWN_EDGE","TimeoutChangeGraphUnitType","MuliplierToDelay","CurrentTime","setTimeout","FindNodeType","TypeToFind","NodeToFind","visited","cords","forEach","col","node","displayShortestPathUsingPreviousNode","timer","TIMER_BETWEEN_RENDERS","FinishNode","StartNode","endingProgramCallback","shortestPath","x","y","traceBackShortestPath","cordInShortestPath","IN_SHORTEST_PATH_NODE","hasNodeNotBeenVisited","GraphNode","memo","setGraph","nodeDiameter","useState","menuOpen","setMenu","className","onClick","style","height","width","NODE","JSON","stringify","generateGraph","startNode","finishNode","retGraph","i","j","generateGraphNode","startXcord","startYCord","Error","finishXcord","finishYCord","e","row","theCords","renderGraph","graph","map","item","GraphComponent","current","runAlgorithim","algoToRun","GRAPH_HEIGHT","GRAPH_WIDTH","DELAY_TIME","BFS","queue","currentNode","shift","currentNodeCordX","currentNodeCordY","VISITED_NODE","GraphHeight","GraphWidth","console","log","breadthFirstSearch","DFS","TIME_TO_DELAY","Stack","unshift","deapthFirstSearch","OptionsBar","setGraphHeight","setGraphWidth","setGraphType","graphType","currentAlgo","setCurrentAlgo","setDelayTime","isAlgoRunning","setIsAlgoRunning","graphSize","setGraphSize","useEffect","setAlgoRunningToFalse","FormControl","InputLabel","Select","labelId","id","value","onChange","target","MenuItem","FormHelperText","Object","entries","Button","variant","color","disabled","resetTheGraph","START_NODE_CORDS","FINISH_NODE_CORDS","Dashboard","startNodeRef","useRef","finishNodeRef","graphHeight","graphWidth","NORMAL","HOLES","prev","ix","iy","src","alt","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.189fa291.chunk.js","sourcesContent":["export type NodeCords = [row: number, col: number];\n\nexport enum graphTypes {\n\tNORMAL = \"Normal\",\n\tHOLES = \"Holes\",\n}\n\nexport enum GraphUnitTypes {\n\tSTART = \"start-node\",\n\tFINISH = \"finish-node\",\n\tNODE = \"normal-node\",\n\tNODE_IN_QUEUE = \"node-in-queue\",\n\tLEFT_RIGHT_EDGE = \"left-right-edge\",\n\tUP_DOWN_EDGE = \"up-down-edge\",\n\tEMPTY_SPACE = \"empty-space\",\n\tVISITED_NODE = \"visited-node\",\n\tIN_SHORTEST_PATH_NODE = \"shortest-path-node\",\n}\n\nexport type GraphUnit = {\n\ttype: GraphUnitTypes;\n\tvisited: boolean;\n\tqueued: boolean;\n\tcords: NodeCords;\n\tprevious?: NodeCords;\n};\n\nexport type GraphType = GraphUnit[][];\n\nexport enum AlgoTypes {\n\tDFS = \"Depth First Search\",\n\tBFS = \"Breadth First Search\",\n}\n","import { GraphType, GraphUnit, GraphUnitTypes, NodeCords } from \"../types\";\n\n//Returns if a node has been queued or not\nexport const hasNodeNotBeenQueued = (Graph: GraphType, MarkingNodeCords: NodeCords) => {\n\tconst nodeInQuestion = Graph[MarkingNodeCords[0]][MarkingNodeCords[1]];\n\tif (!nodeInQuestion.queued) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nconst nodeIsNotEmptySpace = (Graph: GraphType, MarkingNodeCords: NodeCords) => {\n\tconst [X, Y] = MarkingNodeCords;\n\tif (Graph[X][Y].type !== GraphUnitTypes.EMPTY_SPACE) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n//Finds all the nodes around a single node\nexport const findAdjancentNonQueuedNodes = (\n\tNode: NodeCords,\n\tGraph: GraphType,\n\tHeight: number,\n\tWidth: number,\n\tcallbackCheck: (Graph: GraphType, MarkingNodeCords: NodeCords) => boolean\n) => {\n\tconst TopNodeCords: NodeCords = [Node[0], Node[1] - 2];\n\tconst BottomNodeCords: NodeCords = [Node[0], Node[1] + 2];\n\tconst RightNodeCords: NodeCords = [Node[0] + 2, Node[1]];\n\tconst LeftNodeCords: NodeCords = [Node[0] - 2, Node[1]];\n\n\tconst AdjancentNodes: NodeCords[] = [];\n\n\tif (TopNodeCords[1] >= 0 && callbackCheck(Graph, TopNodeCords) && nodeIsNotEmptySpace(Graph, TopNodeCords)) {\n\t\tAdjancentNodes.push(TopNodeCords);\n\t}\n\tif (\n\t\tRightNodeCords[0] < Graph.length &&\n\t\tcallbackCheck(Graph, RightNodeCords) &&\n\t\tnodeIsNotEmptySpace(Graph, RightNodeCords)\n\t) {\n\t\tAdjancentNodes.push(RightNodeCords);\n\t}\n\tif (\n\t\tBottomNodeCords[1] < Graph[0].length &&\n\t\tcallbackCheck(Graph, BottomNodeCords) &&\n\t\tnodeIsNotEmptySpace(Graph, BottomNodeCords)\n\t) {\n\t\tAdjancentNodes.push(BottomNodeCords);\n\t}\n\tif (LeftNodeCords[0] >= 0 && callbackCheck(Graph, LeftNodeCords) && nodeIsNotEmptySpace(Graph, LeftNodeCords)) {\n\t\tAdjancentNodes.push(LeftNodeCords);\n\t}\n\treturn AdjancentNodes;\n};\n\n//Changes a Graph Unit type without time, but with a state update\nexport const ChangeGraphUnitType = (\n\tXcord: number,\n\tYcord: number,\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tTypeToChange: GraphUnitTypes,\n\tdeleteEdges: boolean = false,\n\treplacePreviousEdge: boolean = false\n) => {\n\tSetGraph((prevGraph) => {\n\t\tconst dup = [...prevGraph];\n\n\t\tif (dup[Xcord][Ycord].type !== GraphUnitTypes.START || dup[Xcord][Ycord].type !== GraphUnitTypes.FINISH) {\n\t\t\tdup[Xcord][Ycord].type = TypeToChange;\n\t\t}\n\t\t//for deleting a node and all its edges\n\t\tif (deleteEdges) {\n\t\t\tif (Xcord + 1 < Graph.length) {\n\t\t\t\tdup[Xcord + 1][Ycord].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t}\n\t\t\tif (Xcord - 1 >= 0) {\n\t\t\t\tdup[Xcord - 1][Ycord].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t}\n\t\t\tif (Ycord + 1 < Graph[0].length) {\n\t\t\t\tdup[Xcord][Ycord + 1].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t}\n\t\t\tif (Ycord - 1 >= 0) {\n\t\t\t\tdup[Xcord][Ycord - 1].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t}\n\t\t}\n\t\t//for replacing the edges in the shortest path's path\n\t\tconst prevNode = dup[Xcord][Ycord].previous;\n\t\tif (replacePreviousEdge && prevNode) {\n\t\t\tif (Xcord === prevNode[0]) {\n\t\t\t\tdup[(Xcord + prevNode[0]) / 2][(Ycord + prevNode[1]) / 2].type = GraphUnitTypes.LEFT_RIGHT_EDGE;\n\t\t\t} else {\n\t\t\t\tdup[(Xcord + prevNode[0]) / 2][(Ycord + prevNode[1]) / 2].type = GraphUnitTypes.UP_DOWN_EDGE;\n\t\t\t}\n\t\t}\n\n\t\treturn dup;\n\t});\n};\n\n//Changes a Graph Unit WIth a timeout, and returns a incremented timer for slickness\nexport const TimeoutChangeGraphUnitType = (\n\tXcord: number,\n\tYcord: number,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tTypeToChange: GraphUnitTypes,\n\tMuliplierToDelay: number,\n\tCurrentTime: number,\n\tdeleteEdges: boolean,\n\tGraph: GraphType,\n\treplacePreviousEdge: boolean = false\n) => {\n\tsetTimeout(function () {\n\t\tChangeGraphUnitType(Xcord, Ycord, Graph, SetGraph, TypeToChange, deleteEdges, replacePreviousEdge);\n\t}, CurrentTime * MuliplierToDelay);\n\treturn CurrentTime + 1;\n};\n\n//Returns the first instance of that node type in a graph\nexport const FindNodeType = (Graph: GraphType, TypeToFind: GraphUnitTypes) => {\n\tlet NodeToFind: GraphUnit = {\n\t\ttype: GraphUnitTypes.EMPTY_SPACE,\n\t\tvisited: false,\n\t\tcords: [0, 0],\n\t\tqueued: false,\n\t};\n\tGraph.forEach((col) => {\n\t\tcol.forEach((node) => {\n\t\t\tif (node.type === TypeToFind) {\n\t\t\t\tNodeToFind = node;\n\t\t\t}\n\t\t});\n\t});\n\treturn NodeToFind;\n};\n\nconst traceBackShortestPath = (Graph: GraphType, FinishNode: GraphUnit, StartNode: GraphUnit) => {\n\tconst shortestPath: NodeCords[] = [];\n\tlet node: NodeCords | undefined = Graph[FinishNode.cords[0]][FinishNode.cords[1]].cords;\n\tshortestPath.push(node);\n\n\twhile (node && node !== StartNode.cords) {\n\t\tshortestPath.push(node);\n\t\tconst x: number = node[0];\n\t\tconst y: number = node[1];\n\t\tnode = Graph[x][y].previous;\n\t}\n\n\tif (node) {\n\t\tshortestPath.push(node);\n\t}\n\n\treturn shortestPath;\n};\n\n//Displays the shortest path at the end of depth first and bredth first search through essentially tracing back previous nodes\nexport const displayShortestPathUsingPreviousNode = (\n\ttimer: number,\n\tTIMER_BETWEEN_RENDERS: number,\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tFinishNode: GraphUnit,\n\tStartNode: GraphUnit,\n\tendingProgramCallback: () => void\n) => {\n\tconst shortestPath: NodeCords[] = traceBackShortestPath(Graph, FinishNode, StartNode);\n\tshortestPath.forEach((cordInShortestPath) => {\n\t\tconst [Xcord, Ycord] = cordInShortestPath;\n\t\ttimer = TimeoutChangeGraphUnitType(\n\t\t\tXcord,\n\t\t\tYcord,\n\t\t\tSetGraph,\n\t\t\tGraphUnitTypes.IN_SHORTEST_PATH_NODE,\n\t\t\tTIMER_BETWEEN_RENDERS,\n\t\t\ttimer,\n\t\t\tfalse,\n\t\t\tGraph,\n\t\t\ttrue\n\t\t);\n\t});\n\n\tsetTimeout(() => {\n\t\tendingProgramCallback();\n\t}, timer * TIMER_BETWEEN_RENDERS);\n};\n\n//method that makes a node and all its edges into EMPTY_SPACE\nexport const makeEmptySpace = (\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tXcord: number,\n\tYcord: number,\n\twidth: number,\n\theight: number\n) => {\n\tChangeGraphUnitType(Xcord, Ycord, Graph, SetGraph, GraphUnitTypes.EMPTY_SPACE, false);\n\tdeleteNodeEdges(Graph, SetGraph, Xcord, Ycord, width, height);\n};\n\nexport const deleteNodeEdges = (\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tXcord: number,\n\tYcord: number,\n\twidth: number,\n\theight: number\n) => {\n\t//Getting node neighbors\n\tconst neighbors = findAdjancentNonQueuedNodes([Xcord, Ycord], Graph, height, width, () => true);\n\tneighbors.forEach((item) => {\n\t\tChangeGraphUnitType(\n\t\t\t(Xcord + item[0]) / 2,\n\t\t\t(Ycord + item[1]) / 2,\n\t\t\tGraph,\n\t\t\tSetGraph,\n\t\t\tGraphUnitTypes.EMPTY_SPACE,\n\t\t\tfalse\n\t\t);\n\t});\n};\n","import { GraphType, GraphUnitTypes, NodeCords } from \"../types\";\nimport {\n\tTimeoutChangeGraphUnitType,\n\tFindNodeType,\n\tfindAdjancentNonQueuedNodes,\n\tdisplayShortestPathUsingPreviousNode,\n} from \"../functions/GraphFunctions\";\nimport React from \"react\";\n\nconst hasNodeNotBeenVisited = (Graph: GraphType, MarkingNodeCords: NodeCords) => {\n\tconst nodeInQuestion = Graph[MarkingNodeCords[0]][MarkingNodeCords[1]];\n\tif (!nodeInQuestion.visited) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nexport const deapthFirstSearch = (\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tendingProgramCallback: () => void,\n\tTIME_TO_DELAY: number\n) => {\n\tconst StartNode = FindNodeType(Graph, GraphUnitTypes.START);\n\tconst FinishNode = FindNodeType(Graph, GraphUnitTypes.FINISH);\n\tconst GraphWidth = Graph.length;\n\tconst GraphHeight = Graph[0].length;\n\n\tlet Stack: NodeCords[] = [];\n\tStack.push(StartNode.cords);\n\tlet timer = 0;\n\n\twhile (Stack.length !== 0) {\n\t\tconst currentNode = Stack.shift();\n\n\t\tif (!currentNode) throw new Error(\"The stack was empty when that was already checked\");\n\n\t\tif (currentNode[0] === FinishNode.cords[0] && currentNode[1] === FinishNode.cords[1]) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttimer = TimeoutChangeGraphUnitType(\n\t\t\tcurrentNode[0],\n\t\t\tcurrentNode[1],\n\t\t\tSetGraph,\n\t\t\tGraphUnitTypes.VISITED_NODE,\n\t\t\tTIME_TO_DELAY,\n\t\t\ttimer,\n\t\t\ttrue,\n\t\t\tGraph\n\t\t);\n\t\tconst [Xcord, Ycord] = currentNode;\n\t\tGraph[Xcord][Ycord].visited = true;\n\t\tconst neighbors = findAdjancentNonQueuedNodes(currentNode, Graph, GraphHeight, GraphWidth, hasNodeNotBeenVisited);\n\t\tneighbors.forEach(([X, Y]) => {\n\t\t\tStack.unshift([X, Y]);\n\t\t\tGraph[X][Y].queued = true;\n\t\t\tGraph[X][Y].previous = currentNode;\n\t\t});\n\t}\n\n\tdisplayShortestPathUsingPreviousNode(\n\t\ttimer,\n\t\tTIME_TO_DELAY,\n\t\tGraph,\n\t\tSetGraph,\n\t\tFinishNode,\n\t\tStartNode,\n\t\tendingProgramCallback\n\t);\n};\n","import { GraphType, GraphUnit, GraphUnitTypes } from \"../types\";\nimport { FindNodeType } from \"../functions/GraphFunctions\";\nimport { FC, useState } from \"react\";\nimport { memo } from \"react\";\n\ninterface GraphNodeContents {\n\tGraphNode: GraphUnit;\n\tsetGraph: React.Dispatch<React.SetStateAction<GraphType>>;\n\tGraph: GraphType;\n\tnodeDiameter: number;\n}\n\nconst GraphNode: FC<GraphNodeContents> = memo(({ GraphNode, setGraph, nodeDiameter }) => {\n\tconst [menuOpen, setMenu] = useState(false);\n\tconst handleClick = () => {\n\t\tsetMenu(!menuOpen);\n\t};\n\n\tconst setFinishNode = () => {\n\t\tsetGraph((prevGraph) => {\n\t\t\tconst currentStartNode = FindNodeType(prevGraph, GraphUnitTypes.FINISH);\n\t\t\tcurrentStartNode.type = GraphUnitTypes.NODE;\n\t\t\tconst dup = [...prevGraph];\n\t\t\tconst [X, Y] = GraphNode.cords;\n\t\t\tprevGraph[X][Y].type = GraphUnitTypes.FINISH;\n\t\t\treturn dup;\n\t\t});\n\t\tsetMenu(false);\n\t};\n\n\tconst setStartNode = () => {\n\t\tsetGraph((prevGraph) => {\n\t\t\tconst currentStartNode = FindNodeType(prevGraph, GraphUnitTypes.START);\n\t\t\tcurrentStartNode.type = GraphUnitTypes.NODE;\n\t\t\tconst dup = [...prevGraph];\n\t\t\tconst [X, Y] = GraphNode.cords;\n\t\t\tprevGraph[X][Y].type = GraphUnitTypes.START;\n\t\t\treturn dup;\n\t\t});\n\t\tsetMenu(false);\n\t};\n\n\treturn (\n\t\t<div\n\t\t\tclassName='graph-unit'\n\t\t\tonClick={() => {\n\t\t\t\thandleClick();\n\t\t\t}}\n\t\t\tstyle={{ height: nodeDiameter + \"px\", width: nodeDiameter + \"px\" }}\n\t\t>\n\t\t\t<div className={GraphNode.type}></div>\n\t\t\t{menuOpen &&\n\t\t\t\tGraphNode.type !== GraphUnitTypes.EMPTY_SPACE &&\n\t\t\t\tGraphNode.type !== GraphUnitTypes.LEFT_RIGHT_EDGE &&\n\t\t\t\tGraphNode.type !== GraphUnitTypes.UP_DOWN_EDGE && (\n\t\t\t\t\t<div className='node-selection-menu'>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName='node-selection-menu-option'\n\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tsetStartNode();\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tSet Start Node\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName='node-selection-menu-option'\n\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tsetFinishNode();\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tSet Finish Node\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div className='node-selection-menu-option'>\n\t\t\t\t\t\t\t<h4>{JSON.stringify(GraphNode.cords)}</h4>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t</div>\n\t);\n});\n\nexport default GraphNode;\n","import \"../css/Graph.css\";\nimport { FC } from \"react\";\nimport { GraphType, NodeCords, GraphUnitTypes } from \"../types\";\nimport GraphNode from \"./GraphNode\";\n\n//Function used to generate the code representation of the graph\nexport const generateGraph = (startNode: NodeCords, finishNode: NodeCords, width: number, height: number) => {\n\t//intializing the first start of the graph\n\tconst retGraph: GraphType = [];\n\tfor (let i = 0; i < width; i++) {\n\t\tretGraph[i] = [];\n\t\tfor (let j = 0; j < height; j++) {\n\t\t\tretGraph[i][j] = generateGraphNode(i, j);\n\t\t}\n\t}\n\ttry {\n\t\tconst [startXcord, startYCord] = startNode;\n\t\tif (retGraph[startXcord][startYCord].type === GraphUnitTypes.NODE) {\n\t\t\tretGraph[startXcord][startYCord].type = GraphUnitTypes.START;\n\t\t} else {\n\t\t\tthrow new Error(\"The start node coordinate is not a valid node\");\n\t\t}\n\t\t//setting the finish node\n\t\tconst [finishXcord, finishYCord] = finishNode;\n\t\tif (retGraph[finishXcord][finishYCord].type === GraphUnitTypes.NODE) {\n\t\t\tretGraph[finishXcord][finishYCord].type = GraphUnitTypes.FINISH;\n\t\t} else {\n\t\t\tthrow new Error(\"The finish node coordinate is not a valid node\");\n\t\t}\n\t} catch (e) {\n\t\tretGraph[0][0].type = GraphUnitTypes.START;\n\t\tretGraph[0][2].type = GraphUnitTypes.FINISH;\n\t}\n\t//setting the start node\n\treturn retGraph;\n};\n\n//helper function that generates a node based on a paterrn in order to get the graph / edge ratio that I want in the shape I want\nconst generateGraphNode = (row: number, col: number) => {\n\t//if row is even\n\tif (row % 2 === 0) {\n\t\tif (col % 2 === 0) {\n\t\t\tconst theCords: NodeCords = [row, col];\n\t\t\treturn {\n\t\t\t\ttype: GraphUnitTypes.NODE,\n\t\t\t\tqueued: false,\n\t\t\t\tvisited: false,\n\t\t\t\tcords: theCords,\n\t\t\t};\n\t\t} else {\n\t\t\tconst theCords: NodeCords = [row, col];\n\t\t\treturn {\n\t\t\t\ttype: GraphUnitTypes.LEFT_RIGHT_EDGE,\n\t\t\t\tqueued: false,\n\t\t\t\tvisited: false,\n\t\t\t\tcords: theCords,\n\t\t\t};\n\t\t}\n\t}\n\t// if row is odd\n\telse {\n\t\tif (col % 2 === 0) {\n\t\t\tconst theCords: NodeCords = [row, col];\n\t\t\treturn {\n\t\t\t\ttype: GraphUnitTypes.UP_DOWN_EDGE,\n\t\t\t\tqueued: false,\n\t\t\t\tvisited: false,\n\t\t\t\tcords: theCords,\n\t\t\t};\n\t\t} else {\n\t\t\tconst theCords: NodeCords = [row, col];\n\t\t\treturn {\n\t\t\t\ttype: GraphUnitTypes.EMPTY_SPACE,\n\t\t\t\tqueued: false,\n\t\t\t\tvisited: false,\n\t\t\t\tcords: theCords,\n\t\t\t};\n\t\t}\n\t}\n};\n\n//Generates the react representation from the code representation of the matrix graph\nconst renderGraph = (\n\tgraph: GraphType,\n\tsetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tnodeDiameter: number\n) => {\n\treturn (\n\t\t<>\n\t\t\t{\" \"}\n\t\t\t{graph.map((row, i) => {\n\t\t\t\treturn (\n\t\t\t\t\t<div className='graph-col' key={i}>\n\t\t\t\t\t\t{row.map((item, j) => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<GraphNode\n\t\t\t\t\t\t\t\t\tGraphNode={item}\n\t\t\t\t\t\t\t\t\tsetGraph={setGraph}\n\t\t\t\t\t\t\t\t\tGraph={graph}\n\t\t\t\t\t\t\t\t\tkey={i + 37 * j}\n\t\t\t\t\t\t\t\t\tnodeDiameter={nodeDiameter}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t\t</div>\n\t\t\t\t);\n\t\t\t})}{\" \"}\n\t\t</>\n\t);\n};\ninterface GraphComponentContent {\n\tgraph: GraphType;\n\tsetGraph: React.Dispatch<React.SetStateAction<GraphType>>;\n\tnodeDiameter: React.MutableRefObject<number>;\n}\n\nconst GraphComponent: FC<GraphComponentContent> = ({ graph, setGraph, nodeDiameter }) => {\n\treturn (\n\t\t<div className='graph_meta_container'>\n\t\t\t<div className='graph_container'>{renderGraph(graph, setGraph, nodeDiameter.current)}</div>\n\t\t</div>\n\t);\n};\n\nexport default GraphComponent;\n","import React, { FC, useState } from \"react\";\nimport { breadthFirstSearch } from \"../algos/breadthFirstSearch\";\nimport { deapthFirstSearch } from \"../algos/depthFirstSearch\";\nimport { GraphType, GraphUnit, GraphUnitTypes, AlgoTypes, graphTypes } from \"../types\";\nimport { FindNodeType } from \"../functions/GraphFunctions\";\nimport { generateGraph } from \"../components/Graph\";\nimport \"../css/OptionsBar.css\";\nimport InputLabel from \"@material-ui/core/InputLabel\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport FormHelperText from \"@material-ui/core/FormHelperText\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Select from \"@material-ui/core/Select\";\nimport Button from \"@material-ui/core/Button\";\nimport { useEffect } from \"react\";\n\ninterface OptionsBarContent {\n\tGraph: GraphUnit[][];\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>;\n\tGRAPH_HEIGHT: number;\n\tGRAPH_WIDTH: number;\n\tsetGraphHeight: React.Dispatch<React.SetStateAction<number>>;\n\tsetGraphWidth: React.Dispatch<React.SetStateAction<number>>;\n\tsetGraphType: React.Dispatch<React.SetStateAction<graphTypes>>;\n\tgraphType: graphTypes;\n}\n\nconst runAlgorithim = (\n\talgoToRun: AlgoTypes,\n\tGraph: GraphUnit[][],\n\tsetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tGRAPH_HEIGHT: number,\n\tGRAPH_WIDTH: number,\n\tendingProgramCallback: () => void,\n\tDELAY_TIME: number\n) => {\n\t//resetTheGraph(Graph, setGraph, GRAPH_HEIGHT, GRAPH_WIDTH);\n\tswitch (algoToRun) {\n\t\tcase AlgoTypes.BFS:\n\t\t\tbreadthFirstSearch(Graph, setGraph, endingProgramCallback, DELAY_TIME);\n\t\t\tbreak;\n\t\tcase AlgoTypes.DFS:\n\t\t\tdeapthFirstSearch(Graph, setGraph, endingProgramCallback, DELAY_TIME);\n\t\t\tbreak;\n\t}\n};\n\nconst resetTheGraph = (\n\tGraph: GraphUnit[][],\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tGRAPH_HEIGHT: number,\n\tGRAPH_WIDTH: number,\n\tsetGraphWidth: React.Dispatch<React.SetStateAction<number>>\n) => {\n\tconst StartNode = FindNodeType(Graph, GraphUnitTypes.START);\n\tconst FinishNode = FindNodeType(Graph, GraphUnitTypes.FINISH);\n\tSetGraph(generateGraph(StartNode.cords, FinishNode.cords, GRAPH_HEIGHT, GRAPH_WIDTH));\n\tconst dup = GRAPH_WIDTH;\n\tsetGraphWidth(dup);\n};\n\nconst OptionsBar: FC<OptionsBarContent> = ({\n\tGraph,\n\tSetGraph,\n\tGRAPH_HEIGHT,\n\tGRAPH_WIDTH,\n\tsetGraphHeight,\n\tsetGraphWidth,\n\tsetGraphType,\n\tgraphType,\n}) => {\n\tconst [currentAlgo, setCurrentAlgo] = useState(AlgoTypes.BFS);\n\tconst [DELAY_TIME, setDelayTime] = useState(60);\n\tconst [isAlgoRunning, setIsAlgoRunning] = useState(false);\n\tconst [graphSize, setGraphSize] = useState(21);\n\n\tuseEffect(() => {\n\t\tsetGraphHeight(graphSize as number);\n\t\tsetGraphWidth((graphSize as number) * 2 + 1);\n\t});\n\n\tconst setAlgoRunningToFalse = () => {\n\t\tsetIsAlgoRunning(false);\n\t};\n\n\treturn (\n\t\t<div className='tool-bar'>\n\t\t\t<FormControl style={{ width: \"180px\" }}>\n\t\t\t\t<InputLabel>Graph Size</InputLabel>\n\t\t\t\t<Select\n\t\t\t\t\tlabelId='graph-selector-helper-label'\n\t\t\t\t\tid='graph-selector-helper'\n\t\t\t\t\tvalue={graphSize}\n\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\tsetGraphSize(e.target.value as number);\n\t\t\t\t\t\tsetGraphHeight(e.target.value as number);\n\t\t\t\t\t\tsetGraphWidth((e.target.value as number) * 2 + 1);\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<MenuItem value={3}>Very Small</MenuItem>\n\t\t\t\t\t<MenuItem value={11}>Small</MenuItem>\n\t\t\t\t\t<MenuItem value={21}>Medium</MenuItem>\n\t\t\t\t\t<MenuItem value={27}>Large</MenuItem>\n\t\t\t\t\t<MenuItem value={37}>Extra Large</MenuItem>\n\t\t\t\t\t<MenuItem value={57}>Extra Extra Large</MenuItem>\n\t\t\t\t</Select>\n\t\t\t\t<FormHelperText>The amount of nodes</FormHelperText>\n\t\t\t</FormControl>\n\t\t\t<FormControl style={{ width: \"180px\" }}>\n\t\t\t\t<InputLabel>Algorithim Type</InputLabel>\n\t\t\t\t<Select\n\t\t\t\t\tlabelId='algorithim-selector-helper-label'\n\t\t\t\t\tid='algorithim-selector-helper'\n\t\t\t\t\tvalue={currentAlgo}\n\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\tsetCurrentAlgo(e.target.value as AlgoTypes);\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{Object.entries(AlgoTypes).map((item) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<MenuItem value={item[1]} key={item[1]}>\n\t\t\t\t\t\t\t\t{item[1]}\n\t\t\t\t\t\t\t</MenuItem>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</Select>\n\t\t\t\t<FormHelperText>The Algorithim to run</FormHelperText>\n\t\t\t</FormControl>\n\t\t\t<FormControl style={{ width: \"180px\" }}>\n\t\t\t\t<InputLabel>Algorithim Speed</InputLabel>\n\t\t\t\t<Select\n\t\t\t\t\tlabelId='algorithim-speed-selector-helper-label'\n\t\t\t\t\tid='algorithim-speed-selector-helper'\n\t\t\t\t\tvalue={DELAY_TIME}\n\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\tsetDelayTime(e.target.value as number);\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<MenuItem value={300}>Slow</MenuItem>\n\t\t\t\t\t<MenuItem value={60}>Medium</MenuItem>\n\t\t\t\t\t<MenuItem value={20}>Fast</MenuItem>\n\t\t\t\t</Select>\n\t\t\t\t<FormHelperText>The speed it runs</FormHelperText>\n\t\t\t</FormControl>\n\t\t\t<FormControl style={{ width: \"180px\" }}>\n\t\t\t\t<InputLabel>Graph Type</InputLabel>\n\t\t\t\t<Select\n\t\t\t\t\tlabelId='graph-selector-helper-label'\n\t\t\t\t\tid='graph-selector-helper'\n\t\t\t\t\tvalue={graphType}\n\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\tsetGraphType(e.target.value as graphTypes);\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{Object.entries(graphTypes).map((item) => {\n\t\t\t\t\t\treturn <MenuItem value={item[1]}>{item[1]}</MenuItem>;\n\t\t\t\t\t})}\n\t\t\t\t</Select>\n\t\t\t\t<FormHelperText>The amount of nodes</FormHelperText>\n\t\t\t</FormControl>\n\t\t\t<Button\n\t\t\t\tvariant='contained'\n\t\t\t\tcolor='primary'\n\t\t\t\tdisabled={isAlgoRunning}\n\t\t\t\tonClick={() => {\n\t\t\t\t\tif (!isAlgoRunning) {\n\t\t\t\t\t\trunAlgorithim(currentAlgo, Graph, SetGraph, GRAPH_HEIGHT, GRAPH_WIDTH, setAlgoRunningToFalse, DELAY_TIME);\n\t\t\t\t\t\tsetIsAlgoRunning(true);\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tRun Algorithim\n\t\t\t</Button>\n\t\t\t<Button\n\t\t\t\tvariant='contained'\n\t\t\t\tcolor='secondary'\n\t\t\t\tdisabled={isAlgoRunning}\n\t\t\t\tonClick={() => {\n\t\t\t\t\tif (!isAlgoRunning) {\n\t\t\t\t\t\tresetTheGraph(Graph, SetGraph, GRAPH_HEIGHT, GRAPH_WIDTH, setGraphWidth);\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tReset\n\t\t\t</Button>\n\t\t</div>\n\t);\n};\n\nexport default OptionsBar;\n","import { GraphType, GraphUnitTypes, NodeCords } from \"../types\";\nimport {\n\tTimeoutChangeGraphUnitType,\n\tFindNodeType,\n\tfindAdjancentNonQueuedNodes,\n\tdisplayShortestPathUsingPreviousNode,\n\thasNodeNotBeenQueued,\n} from \"../functions/GraphFunctions\";\n\nexport const breadthFirstSearch = (\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tendingProgramCallback: () => void,\n\tTIMER_BETWEEN_RENDERS: number\n) => {\n\tconst StartNode = FindNodeType(Graph, GraphUnitTypes.START);\n\tconst FinishNode = FindNodeType(Graph, GraphUnitTypes.FINISH);\n\tconst GraphWidth = Graph.length;\n\tconst GraphHeight = Graph[0].length;\n\n\tlet queue: NodeCords[] = [];\n\tqueue.push(StartNode.cords);\n\n\t//timer to help with calcuation\n\tlet timer = 0;\n\n\twhile (queue.length !== 0) {\n\t\tconst currentNode = queue.shift();\n\t\tif (currentNode) {\n\t\t\tconst [currentNodeCordX, currentNodeCordY] = currentNode;\n\t\t\tGraph[currentNodeCordX][currentNodeCordY].queued = true;\n\t\t\t//Chaning the state of a node\n\t\t\tconst [Xcord, Ycord] = currentNode;\n\t\t\ttimer = TimeoutChangeGraphUnitType(\n\t\t\t\tXcord,\n\t\t\t\tYcord,\n\t\t\t\tSetGraph,\n\t\t\t\tGraphUnitTypes.VISITED_NODE,\n\t\t\t\tTIMER_BETWEEN_RENDERS,\n\t\t\t\ttimer,\n\t\t\t\ttrue,\n\t\t\t\tGraph\n\t\t\t);\n\t\t}\n\t\t//null check for typescript\n\t\tif (!currentNode) {\n\t\t\tconsole.log(\"there was nothing let in the queue\");\n\t\t\tbreak;\n\t\t}\n\t\t//if finish node was found\n\t\tif (currentNode[0] === FinishNode.cords[0] && currentNode[1] === FinishNode.cords[1]) {\n\t\t\tbreak;\n\t\t}\n\t\t//Gets neighbors and sets all visited to true for them to avoid putting them in the queue twice\n\t\tconst AllNeighbors = findAdjancentNonQueuedNodes(currentNode, Graph, GraphHeight, GraphWidth, hasNodeNotBeenQueued);\n\t\tAllNeighbors.forEach((item) => {\n\t\t\tqueue.push(item);\n\t\t\tconst [Xcord, Ycord] = item;\n\t\t\tGraph[Xcord][Ycord].queued = true;\n\t\t\tGraph[Xcord][Ycord].previous = currentNode;\n\t\t});\n\t}\n\n\tdisplayShortestPathUsingPreviousNode(\n\t\ttimer,\n\t\tTIMER_BETWEEN_RENDERS,\n\t\tGraph,\n\t\tSetGraph,\n\t\tFinishNode,\n\t\tStartNode,\n\t\tendingProgramCallback\n\t);\n};\n","import React from \"react\";\nimport { FC, useRef, useState } from \"react\";\nimport OptionsBar from \"./OptionsBar\";\nimport GraphComponent, { generateGraph } from \"./Graph\";\nimport { NodeCords, GraphUnitTypes, graphTypes } from \"../types\";\nimport { useEffect } from \"react\";\nimport \"../css/Dashboard.css\";\n\nconst START_NODE_CORDS: NodeCords = [0, 0];\nconst FINISH_NODE_CORDS: NodeCords = [6, 6];\n\nconst Dashboard: FC = () => {\n\tconst startNodeRef = useRef(START_NODE_CORDS);\n\tconst finishNodeRef = useRef(FINISH_NODE_CORDS);\n\tconst nodeDiameter = useRef(21);\n\tconst [graphHeight, setGraphHeight] = useState(21);\n\tconst [graphWidth, setGraphWidth] = useState(43);\n\tconst [graph, setGraph] = useState(\n\t\tgenerateGraph(startNodeRef.current, finishNodeRef.current, graphHeight, graphWidth)\n\t);\n\tconst [graphType, setGraphType] = useState(graphTypes.NORMAL);\n\n\tuseEffect(() => {\n\t\tconst graphWidthPixels = 1000;\n\t\tnodeDiameter.current = graphWidthPixels / graphWidth;\n\t\tsetGraph(generateGraph(startNodeRef.current, finishNodeRef.current, graphHeight, graphWidth));\n\t}, [graphWidth, graphHeight]);\n\n\tuseEffect(() => {\n\t\tswitch (graphType) {\n\t\t\tcase graphTypes.NORMAL:\n\t\t\t\tsetGraph(generateGraph(startNodeRef.current, finishNodeRef.current, graphHeight, graphWidth));\n\t\t\t\tbreak;\n\t\t\tcase graphTypes.HOLES:\n\t\t\t\tsetGraph((prev) => {\n\t\t\t\t\tconst dup = [...prev];\n\t\t\t\t\tdup.forEach((row, ix) => {\n\t\t\t\t\t\trow.forEach((node, iy) => {\n\t\t\t\t\t\t\tif (dup[ix][iy].type === GraphUnitTypes.FINISH) {\n\t\t\t\t\t\t\t} else if (dup[ix][iy].type === GraphUnitTypes.START) {\n\t\t\t\t\t\t\t} else if (iy % 6 === 0 && ix % 6 === 0) {\n\t\t\t\t\t\t\t\tdup[ix][iy].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t\t\t\t\t\tif (ix + 1 < dup.length) {\n\t\t\t\t\t\t\t\t\tdup[ix + 1][iy].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ix - 1 > 0) {\n\t\t\t\t\t\t\t\t\tdup[ix - 1][iy].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (iy + 1 < dup[0].length) {\n\t\t\t\t\t\t\t\t\tdup[ix][iy + 1].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (iy - 1 > 0) {\n\t\t\t\t\t\t\t\t\tdup[ix][iy - 1].type = GraphUnitTypes.EMPTY_SPACE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn dup;\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t}\n\t}, [graphType, graphHeight, graphWidth]);\n\n\treturn (\n\t\t<div className='dashboard_container'>\n\t\t\t<div className='title-container'>\n\t\t\t\t<img src='/algorithm-visualizer/apple-touch-icon.png' alt='Website Logo' width={50} height={50} />\n\t\t\t\t<h1>Pathfinding Visualizer</h1>\n\t\t\t\t<img src='/algorithm-visualizer/apple-touch-icon.png' alt='Website Logo' width={50} height={50} />\n\t\t\t</div>\n\t\t\t<GraphComponent graph={graph} setGraph={setGraph} nodeDiameter={nodeDiameter} />\n\t\t\t<OptionsBar\n\t\t\t\tGraph={graph}\n\t\t\t\tSetGraph={setGraph}\n\t\t\t\tGRAPH_HEIGHT={graphHeight}\n\t\t\t\tGRAPH_WIDTH={graphWidth}\n\t\t\t\tsetGraphHeight={setGraphHeight}\n\t\t\t\tsetGraphWidth={setGraphWidth}\n\t\t\t\tsetGraphType={setGraphType}\n\t\t\t\tgraphType={graphType}\n\t\t\t/>\n\t\t</div>\n\t);\n};\n\nexport default Dashboard;\n","import React from \"react\";\nimport \"./css/App.css\";\nimport Dashboard from \"./components/Dashboard\";\nfunction App() {\n\treturn (\n\t\t<div className='App'>\n\t\t\t<Dashboard></Dashboard>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}