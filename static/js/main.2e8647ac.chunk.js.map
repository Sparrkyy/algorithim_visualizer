{"version":3,"sources":["types.ts","functions/GraphFunctions.ts","components/GraphNode.tsx","algos/depthFirstSearch.ts","components/OptionsBar.tsx","algos/breadthFirstSearch.ts","components/Graph.tsx","App.tsx","index.tsx"],"names":["GraphUnitTypes","AlgoTypes","hasNodeNotBeenQueued","Graph","MarkingNodeCords","queued","findAdjancentNonQueuedNodes","Node","Height","Width","callbackCheck","TopNodeCords","BottomNodeCords","RightNodeCords","LeftNodeCords","AdjancentNodes","push","TimeoutChangeGraphUnitType","Xcord","Ycord","SetGraph","TypeToChange","MuliplierToDelay","CurrentTime","setTimeout","prevGraph","dup","type","START","FINISH","console","log","ChangeGraphUnitType","FindNodeType","TypeToFind","NodeToFind","EMPTY_SPACE","visited","cords","forEach","col","node","displayShortestPathUsingPreviousNode","timer","TIMER_BETWEEN_RENDERS","FinishNode","StartNode","endingProgramCallback","shortestPath","finishNode","previous","Error","prevNode","cordInShortestPath","IN_SHORTEST_PATH_NODE","GraphNode","memo","setGraph","useState","menuOpen","setMenu","className","onClick","LEFT_RIGHT_EDGE","UP_DOWN_EDGE","NODE","X","Y","hasNodeNotBeenVisited","runAlgorithim","algoToRun","GRAPH_HEIGHT","GRAPH_WIDTH","DELAY_TIME","resetTheGraph","BFS","GraphWidth","length","GraphHeight","queue","currentNode","shift","currentNodeCordX","currentNodeCordY","VISITED_NODE","item","breadthFirstSearch","DFS","TIME_TO_DELAY","Stack","neighbors","unshift","filter","deapthFirstSearch","generateGraph","OptionsBar","currentAlgo","setCurrentAlgo","setDelayTime","isAlgoRunning","setIsAlgoRunning","setAlgoRunningToFalse","FormControl","style","width","InputLabel","Select","labelId","id","value","onChange","e","target","Object","entries","map","MenuItem","FormHelperText","Button","variant","color","disabled","START_NODE_CORDS","FINISH_NODE_CORDS","startNode","height","retGraph","i","j","generateGraphNode","startXcord","startYCord","finishXcord","finishYCord","row","theCords","GraphComponent","graph","startNodeRef","useRef","finishNodeRef","current","display","justifyContent","alignItems","flexDirection","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2e8647ac.chunk.js","sourcesContent":["export type NodeCords = [row: number, col: number];\n\nexport enum GraphUnitTypes {\n  START = \"start-node\",\n  FINISH = \"finish-node\",\n  NODE = \"normal-node\",\n  NODE_IN_QUEUE = \"node-in-queue\",\n  LEFT_RIGHT_EDGE = \"left-right-edge\",\n  UP_DOWN_EDGE = \"up-down-edge\",\n  EMPTY_SPACE = \"empty-space\",\n  VISITED_NODE = \"visited-node\",\n  IN_SHORTEST_PATH_NODE = \"shortest-path-node\",\n}\n\nexport type GraphUnit = {\n  type: GraphUnitTypes;\n  visited: boolean;\n  queued: boolean;\n  cords: NodeCords;\n  previous?: NodeCords;\n};\n\nexport type GraphType = GraphUnit[][];\n\nexport enum AlgoTypes {\n  DFS = \"Depth First Search\",\n  BFS = \"Breadth First Search\",\n}\n","import { GraphType, GraphUnit, GraphUnitTypes, NodeCords } from \"../types\";\n\n//Returns if a node has been queued or not\nexport const hasNodeNotBeenQueued = (\n  Graph: GraphType,\n  MarkingNodeCords: NodeCords\n) => {\n  const nodeInQuestion = Graph[MarkingNodeCords[0]][MarkingNodeCords[1]];\n  if (!nodeInQuestion.queued) {\n    return true;\n  }\n  return false;\n};\n\n//Finds all the nodes around a single node\nexport const findAdjancentNonQueuedNodes = (\n  Node: NodeCords,\n  Graph: GraphType,\n  Height: number,\n  Width: number,\n  callbackCheck: (Graph: GraphType, MarkingNodeCords: NodeCords) => boolean\n) => {\n  const TopNodeCords: NodeCords = [Node[0], Node[1] - 2];\n  const BottomNodeCords: NodeCords = [Node[0], Node[1] + 2];\n  const RightNodeCords: NodeCords = [Node[0] + 2, Node[1]];\n  const LeftNodeCords: NodeCords = [Node[0] - 2, Node[1]];\n\n  const AdjancentNodes: NodeCords[] = [];\n  //I should make a function for this\n  //Graph[TopNodeCords[0]][TopNodeCords[1]].type !== GraphUnitTypes.VISITED_NODE && Graph[TopNodeCords[0]][TopNodeCords[1]].type !== GraphUnitTypes.NODE_IN_QUEUE\n\n  //Graph[TopNodeCords[0]][TopNodeCords[1]].visited === false\n  if (TopNodeCords[1] >= 0 && callbackCheck(Graph, TopNodeCords)) {\n    AdjancentNodes.push(TopNodeCords);\n  }\n  //Graph[RightNodeCords[0]][RightNodeCords[1]].visited === false\n  if (RightNodeCords[0] <= Width && callbackCheck(Graph, RightNodeCords)) {\n    AdjancentNodes.push(RightNodeCords);\n  }\n  //Graph[BottomNodeCords[0]][BottomNodeCords[1]].visited === false\n  if (BottomNodeCords[1] <= Height && callbackCheck(Graph, BottomNodeCords)) {\n    AdjancentNodes.push(BottomNodeCords);\n  }\n  //Graph[LeftNodeCords[0]][LeftNodeCords[1]].visited === false\n  if (LeftNodeCords[0] >= 0 && callbackCheck(Graph, LeftNodeCords)) {\n    AdjancentNodes.push(LeftNodeCords);\n  }\n  return AdjancentNodes;\n};\n\n//Changes a Graph Unit type without time, but with a state update\nexport const ChangeGraphUnitType = (\n  Xcord: number,\n  Ycord: number,\n  SetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n  TypeToChange: GraphUnitTypes\n) => {\n  SetGraph((prevGraph) => {\n    const dup = [...prevGraph];\n    if (\n      dup[Xcord][Ycord].type !== GraphUnitTypes.START ||\n      dup[Xcord][Ycord].type !== GraphUnitTypes.FINISH\n    ) {\n      dup[Xcord][Ycord].type = TypeToChange;\n    } else {\n      console.log(dup[Xcord][Ycord].type);\n    }\n    return dup;\n  });\n};\n\n//Changes a Graph Unit WIth a timeout, and returns a incremented timer for slickness\nexport const TimeoutChangeGraphUnitType = (\n  Xcord: number,\n  Ycord: number,\n  SetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n  TypeToChange: GraphUnitTypes,\n  MuliplierToDelay: number,\n  CurrentTime: number\n) => {\n  setTimeout(function () {\n    ChangeGraphUnitType(Xcord, Ycord, SetGraph, TypeToChange);\n  }, CurrentTime * MuliplierToDelay);\n  return CurrentTime + 1;\n};\n\n//Returns the first instance of that node type in a graph\nexport const FindNodeType = (Graph: GraphType, TypeToFind: GraphUnitTypes) => {\n  let NodeToFind: GraphUnit = {\n    type: GraphUnitTypes.EMPTY_SPACE,\n    visited: false,\n    cords: [0, 0],\n    queued: false,\n  };\n  Graph.forEach((col) => {\n    col.forEach((node) => {\n      if (node.type === TypeToFind) {\n        NodeToFind = node;\n      }\n    });\n  });\n  return NodeToFind;\n};\n\n//Displays the shortest path at the end of depth first and bredth first search through essentially tracing back previous nodes\nexport const displayShortestPathUsingPreviousNode = (\n  timer: number,\n  TIMER_BETWEEN_RENDERS: number,\n  Graph: GraphType,\n  SetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n  FinishNode: GraphUnit,\n  StartNode: GraphUnit,\n  endingProgramCallback: () => void\n) => {\n  //displaying the shortest path by following the linked list back\n\n  //intializing the array of node for shortest path\n  const shortestPath: NodeCords[] = [];\n  const finishNode = Graph[FinishNode.cords[0]][FinishNode.cords[1]];\n  shortestPath.push(finishNode.cords);\n  //typescript check\n  if (!finishNode.previous) {\n    throw new Error(\"The FINISH NODE did not have a previous node\");\n  }\n  let prevNode: NodeCords | undefined = finishNode.previous;\n  //Follows the link list back like a linked list\n  while (prevNode !== StartNode.cords && prevNode) {\n    shortestPath.push(prevNode);\n    prevNode = Graph[prevNode[0]][prevNode[1]].previous;\n  }\n  //Going through the shortest path and calling the render change function for each\n  shortestPath.forEach((cordInShortestPath) => {\n    const [Xcord, Ycord] = cordInShortestPath;\n    timer = TimeoutChangeGraphUnitType(\n      Xcord,\n      Ycord,\n      SetGraph,\n      GraphUnitTypes.IN_SHORTEST_PATH_NODE,\n      TIMER_BETWEEN_RENDERS,\n      timer\n    );\n  });\n\n  //recoloring the START node\n  timer = TimeoutChangeGraphUnitType(\n    StartNode.cords[0],\n    StartNode.cords[1],\n    SetGraph,\n    GraphUnitTypes.START,\n    TIMER_BETWEEN_RENDERS,\n    timer\n  );\n  //recoloring the FINISH node\n  timer = TimeoutChangeGraphUnitType(\n    FinishNode.cords[0],\n    FinishNode.cords[1],\n    SetGraph,\n    GraphUnitTypes.FINISH,\n    TIMER_BETWEEN_RENDERS,\n    timer\n  );\n\n  setTimeout(() => {\n    endingProgramCallback();\n  }, timer * TIMER_BETWEEN_RENDERS);\n};\n","import { GraphType, GraphUnit, GraphUnitTypes } from \"../types\";\nimport { FindNodeType } from \"../functions/GraphFunctions\";\nimport { FC, useState } from \"react\";\nimport { memo } from \"react\";\n\ninterface GraphNodeContents {\n\tGraphNode: GraphUnit;\n\tsetGraph: React.Dispatch<React.SetStateAction<GraphType>>;\n\tGraph: GraphType;\n}\n\nconst GraphNode: FC<GraphNodeContents> = memo(({ GraphNode, setGraph }) => {\n\tconst [menuOpen, setMenu] = useState(false);\n\tconst handleClick = () => {\n\t\tsetMenu(!menuOpen);\n\t};\n\n\tconst setFinishNode = () => {\n\t\tsetGraph((prevGraph) => {\n\t\t\tconst currentStartNode = FindNodeType(prevGraph, GraphUnitTypes.FINISH);\n\t\t\tcurrentStartNode.type = GraphUnitTypes.NODE;\n\t\t\tconst dup = [...prevGraph];\n\t\t\tconst [X, Y] = GraphNode.cords;\n\t\t\tprevGraph[X][Y].type = GraphUnitTypes.FINISH;\n\t\t\treturn dup;\n\t\t});\n\t\tsetMenu(false);\n\t};\n\n\tconst setStartNode = () => {\n\t\tsetGraph((prevGraph) => {\n\t\t\tconst currentStartNode = FindNodeType(prevGraph, GraphUnitTypes.START);\n\t\t\tcurrentStartNode.type = GraphUnitTypes.NODE;\n\t\t\tconst dup = [...prevGraph];\n\t\t\tconst [X, Y] = GraphNode.cords;\n\t\t\tprevGraph[X][Y].type = GraphUnitTypes.START;\n\t\t\treturn dup;\n\t\t});\n\t\tsetMenu(false);\n\t};\n\n\treturn (\n\t\t<div\n\t\t\tclassName='graph-unit'\n\t\t\tonClick={() => {\n\t\t\t\thandleClick();\n\t\t\t}}\n\t\t>\n\t\t\t<div className={GraphNode.type}>\n\t\t\t\t{/* {item.type === GraphUnitTypes.NODE || item.type === GraphUnitTypes.VISITED_NODE\n\t\t\t\t\t\t\t\t\t\t\t? item.cords[0] + \" \" + item.cords[1]\n\t\t\t\t\t\t\t\t\t\t\t: null} */}\n\t\t\t</div>\n\t\t\t{menuOpen &&\n\t\t\t\tGraphNode.type !== GraphUnitTypes.EMPTY_SPACE &&\n\t\t\t\tGraphNode.type !== GraphUnitTypes.LEFT_RIGHT_EDGE &&\n\t\t\t\tGraphNode.type !== GraphUnitTypes.UP_DOWN_EDGE && (\n\t\t\t\t\t<div className='node-selection-menu'>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName='node-selection-menu-option'\n\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tsetStartNode();\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tSet Start Node\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName='node-selection-menu-option'\n\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\tsetFinishNode();\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tSet Finish Node\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t</div>\n\t);\n});\n\nexport default GraphNode;\n","import { GraphType, GraphUnitTypes, NodeCords } from \"../types\";\nimport {\n\tTimeoutChangeGraphUnitType,\n\tFindNodeType,\n\tfindAdjancentNonQueuedNodes,\n\tdisplayShortestPathUsingPreviousNode,\n} from \"../functions/GraphFunctions\";\nimport React from \"react\";\n\n//const TIME_TO_DELAY_DEFAULT = 1000;\n\nconst hasNodeNotBeenVisited = (Graph: GraphType, MarkingNodeCords: NodeCords) => {\n\tconst nodeInQuestion = Graph[MarkingNodeCords[0]][MarkingNodeCords[1]];\n\tif (!nodeInQuestion.visited) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\nexport const deapthFirstSearch = (\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tendingProgramCallback: () => void,\n\tTIME_TO_DELAY: number\n) => {\n\tconst StartNode = FindNodeType(Graph, GraphUnitTypes.START);\n\tconst FinishNode = FindNodeType(Graph, GraphUnitTypes.FINISH);\n\tconst GraphWidth = Graph.length;\n\tconst GraphHeight = Graph[0].length;\n\n\t//intialize the stack\n\tlet Stack: NodeCords[] = [];\n\tStack.push(StartNode.cords);\n\n\t//timer to help with calcuation\n\tlet timer = 0;\n\n\t//while the stack isnt empty\n\twhile (Stack.length !== 0) {\n\t\tconst currentNode = Stack.shift();\n\n\t\tif (!currentNode) throw new Error(\"The stack was empty when that was already checked\");\n\t\ttimer = TimeoutChangeGraphUnitType(\n\t\t\tcurrentNode[0],\n\t\t\tcurrentNode[1],\n\t\t\tSetGraph,\n\t\t\tGraphUnitTypes.VISITED_NODE,\n\t\t\tTIME_TO_DELAY,\n\t\t\ttimer\n\t\t);\n\t\tconst [Xcord, Ycord] = currentNode;\n\t\tGraph[Xcord][Ycord].visited = true;\n\t\tconst neighbors = findAdjancentNonQueuedNodes(currentNode, Graph, GraphHeight, GraphWidth, hasNodeNotBeenVisited);\n\t\tneighbors.forEach(([X, Y]) => {\n\t\t\tStack.unshift([X, Y]);\n\t\t\tGraph[X][Y].queued = true;\n\t\t\tGraph[X][Y].previous = currentNode;\n\t\t});\n\t\tif (neighbors.filter(([X, Y]) => Graph[X][Y].type === GraphUnitTypes.FINISH).length > 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdisplayShortestPathUsingPreviousNode(\n\t\ttimer,\n\t\tTIME_TO_DELAY,\n\t\tGraph,\n\t\tSetGraph,\n\t\tFinishNode,\n\t\tStartNode,\n\t\tendingProgramCallback\n\t);\n};\n","import React, { FC, useState } from \"react\";\nimport { breadthFirstSearch } from \"../algos/breadthFirstSearch\";\nimport { deapthFirstSearch } from \"../algos/depthFirstSearch\";\nimport { GraphType, GraphUnit, GraphUnitTypes, AlgoTypes } from \"../types\";\nimport { FindNodeType } from \"../functions/GraphFunctions\";\nimport { generateGraph } from \"../components/Graph\";\n//import DropdownSelector from \"./DropdownSelector\";\nimport \"../css/Toolbar.css\";\nimport InputLabel from \"@material-ui/core/InputLabel\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport FormHelperText from \"@material-ui/core/FormHelperText\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Select from \"@material-ui/core/Select\";\nimport Button from \"@material-ui/core/Button\";\n\ninterface OptionsBarContent {\n\tGraph: GraphUnit[][];\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>;\n\tGRAPH_HEIGHT: number;\n\tGRAPH_WIDTH: number;\n}\n\nconst runAlgorithim = (\n\talgoToRun: AlgoTypes,\n\tGraph: GraphUnit[][],\n\tsetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tGRAPH_HEIGHT: number,\n\tGRAPH_WIDTH: number,\n\tendingProgramCallback: () => void,\n\tDELAY_TIME: number\n) => {\n\tresetTheGraph(Graph, setGraph, GRAPH_HEIGHT, GRAPH_WIDTH);\n\tswitch (algoToRun) {\n\t\tcase AlgoTypes.BFS:\n\t\t\tbreadthFirstSearch(Graph, setGraph, endingProgramCallback, DELAY_TIME);\n\t\t\tbreak;\n\t\tcase AlgoTypes.DFS:\n\t\t\tdeapthFirstSearch(Graph, setGraph, endingProgramCallback, DELAY_TIME);\n\t\t\tbreak;\n\t}\n};\n\nconst resetTheGraph = (\n\tGraph: GraphUnit[][],\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tGRAPH_HEIGHT: number,\n\tGRAPH_WIDTH: number\n) => {\n\tconst StartNode = FindNodeType(Graph, GraphUnitTypes.START);\n\tconst FinishNode = FindNodeType(Graph, GraphUnitTypes.FINISH);\n\tSetGraph(generateGraph(StartNode.cords, FinishNode.cords, GRAPH_HEIGHT, GRAPH_WIDTH));\n};\n\nconst OptionsBar: FC<OptionsBarContent> = ({ Graph, SetGraph, GRAPH_HEIGHT, GRAPH_WIDTH }) => {\n\tconst [currentAlgo, setCurrentAlgo] = useState(AlgoTypes.BFS);\n\tconst [DELAY_TIME, setDelayTime] = useState(40);\n\tconst [isAlgoRunning, setIsAlgoRunning] = useState(false);\n\n\tconst setAlgoRunningToFalse = () => {\n\t\tsetIsAlgoRunning(false);\n\t};\n\n\treturn (\n\t\t<div className='tool-bar'>\n\t\t\t<FormControl style={{ width: \"180px\" }}>\n\t\t\t\t<InputLabel>Algorithim Type</InputLabel>\n\t\t\t\t<Select\n\t\t\t\t\tlabelId='algorithim-selector-helper-label'\n\t\t\t\t\tid='algorithim-selector-helper'\n\t\t\t\t\tvalue={currentAlgo}\n\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\tsetCurrentAlgo(e.target.value as AlgoTypes);\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{Object.entries(AlgoTypes).map((item) => {\n\t\t\t\t\t\treturn <MenuItem value={item[1]}>{item[1]}</MenuItem>;\n\t\t\t\t\t})}\n\t\t\t\t</Select>\n\t\t\t\t<FormHelperText>The Algorithim to run</FormHelperText>\n\t\t\t</FormControl>\n\t\t\t<FormControl style={{ width: \"180px\" }}>\n\t\t\t\t<InputLabel>Algorithim Speed</InputLabel>\n\t\t\t\t<Select\n\t\t\t\t\tlabelId='algorithim-speed-selector-helper-label'\n\t\t\t\t\tid='algorithim-speed-selector-helper'\n\t\t\t\t\tvalue={DELAY_TIME}\n\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\tsetDelayTime(e.target.value as number);\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<MenuItem value={60}>Slow</MenuItem>\n\t\t\t\t\t<MenuItem value={40}>Medium</MenuItem>\n\t\t\t\t\t<MenuItem value={20}>Fast</MenuItem>\n\t\t\t\t</Select>\n\t\t\t\t<FormHelperText>The speed it runs</FormHelperText>\n\t\t\t</FormControl>\n\t\t\t<Button\n\t\t\t\tvariant='contained'\n\t\t\t\tcolor='primary'\n\t\t\t\tdisabled={isAlgoRunning}\n\t\t\t\tonClick={() => {\n\t\t\t\t\tif (!isAlgoRunning) {\n\t\t\t\t\t\trunAlgorithim(currentAlgo, Graph, SetGraph, GRAPH_HEIGHT, GRAPH_WIDTH, setAlgoRunningToFalse, DELAY_TIME);\n\t\t\t\t\t\tsetIsAlgoRunning(true);\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tRun Algorithim\n\t\t\t</Button>\n\t\t\t<Button\n\t\t\t\tvariant='contained'\n\t\t\t\tcolor='secondary'\n\t\t\t\tdisabled={isAlgoRunning}\n\t\t\t\tonClick={() => {\n\t\t\t\t\tif (!isAlgoRunning) {\n\t\t\t\t\t\tresetTheGraph(Graph, SetGraph, GRAPH_HEIGHT, GRAPH_WIDTH);\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tReset\n\t\t\t</Button>\n\t\t</div>\n\t);\n};\n\nexport default OptionsBar;\n","import { GraphType, GraphUnitTypes, NodeCords } from \"../types\";\nimport {\n\tTimeoutChangeGraphUnitType,\n\tFindNodeType,\n\tfindAdjancentNonQueuedNodes,\n\tdisplayShortestPathUsingPreviousNode,\n\thasNodeNotBeenQueued,\n} from \"../functions/GraphFunctions\";\n\n//const TIMER_BETWEEN_RENDERS = 30;\n\nexport const breadthFirstSearch = (\n\tGraph: GraphType,\n\tSetGraph: React.Dispatch<React.SetStateAction<GraphType>>,\n\tendingProgramCallback: () => void,\n\tTIMER_BETWEEN_RENDERS: number\n) => {\n\tconst StartNode = FindNodeType(Graph, GraphUnitTypes.START);\n\tconst FinishNode = FindNodeType(Graph, GraphUnitTypes.FINISH);\n\tconst GraphWidth = Graph.length;\n\tconst GraphHeight = Graph[0].length;\n\n\tlet queue: NodeCords[] = [];\n\tqueue.push(StartNode.cords);\n\n\t//timer to help with calcuation\n\tlet timer = 0;\n\n\twhile (Graph[FinishNode.cords[0]][FinishNode.cords[1]].queued !== true) {\n\t\t//Grabs first node in the list\n\t\tconst currentNode = queue.shift();\n\t\tif (currentNode) {\n\t\t\tconst [currentNodeCordX, currentNodeCordY] = currentNode;\n\t\t\tGraph[currentNodeCordX][currentNodeCordY].queued = true;\n\t\t\t//Chaning the state of a node\n\t\t\tconst [Xcord, Ycord] = currentNode;\n\t\t\ttimer = TimeoutChangeGraphUnitType(\n\t\t\t\tXcord,\n\t\t\t\tYcord,\n\t\t\t\tSetGraph,\n\t\t\t\tGraphUnitTypes.VISITED_NODE,\n\t\t\t\tTIMER_BETWEEN_RENDERS,\n\t\t\t\ttimer\n\t\t\t);\n\t\t}\n\n\t\tif (!currentNode) {\n\t\t\tconsole.log(\"there was nothing let in the queue\");\n\t\t\tbreak;\n\t\t}\n\t\t//Gets neighbors and sets all visited to true for them to avoid putting them in the queue twice\n\t\tconst AllNeighbors = findAdjancentNonQueuedNodes(currentNode, Graph, GraphHeight, GraphWidth, hasNodeNotBeenQueued);\n\t\tAllNeighbors.forEach((item) => {\n\t\t\tqueue.push(item);\n\t\t\tconst [Xcord, Ycord] = item;\n\t\t\tGraph[Xcord][Ycord].queued = true;\n\t\t\tGraph[Xcord][Ycord].previous = currentNode;\n\t\t});\n\t}\n\n\tdisplayShortestPathUsingPreviousNode(\n\t\ttimer,\n\t\tTIMER_BETWEEN_RENDERS,\n\t\tGraph,\n\t\tSetGraph,\n\t\tFinishNode,\n\t\tStartNode,\n\t\tendingProgramCallback\n\t);\n};\n","//import { v4 as uuidv4 } from \"uuid\";\nimport \"../css/Graph.css\";\nimport { useState } from \"react\";\nimport { GraphType, NodeCords, GraphUnitTypes } from \"../types\";\n//import { breadthFirstSearch } from \"../algos/breadthFirstSearch\";\n//import { deapthFirstSearch } from \"../algos/depthFirstSearch\";\n//import { FindNodeType } from \"../functions/GraphFunctions\";\nimport { useRef } from \"react\";\nimport GraphNode from \"./GraphNode\";\nimport OptionsBar from \"./OptionsBar\";\n\nconst START_NODE_CORDS: NodeCords = [6, 6];\nconst FINISH_NODE_CORDS: NodeCords = [20, 34];\nconst GRAPH_HEIGHT: number = 23;\nconst GRAPH_WIDTH: number = 51;\n\n//Function used to generate the code representation of the graph\nexport const generateGraph = (\n  startNode: NodeCords,\n  finishNode: NodeCords,\n  width: number,\n  height: number\n) => {\n  //intializing the first start of the graph\n  const retGraph: GraphType = [];\n  for (let i = 0; i < width; i++) {\n    retGraph[i] = [];\n    for (let j = 0; j < height; j++) {\n      retGraph[i][j] = generateGraphNode(i, j);\n    }\n  }\n  //setting the start node\n  const [startXcord, startYCord] = startNode;\n  if (retGraph[startXcord][startYCord].type === GraphUnitTypes.NODE) {\n    retGraph[startXcord][startYCord].type = GraphUnitTypes.START;\n  } else {\n    throw new Error(\"The start node coordinate is not a valid node\");\n  }\n  //setting the finish node\n  const [finishXcord, finishYCord] = finishNode;\n  if (retGraph[finishXcord][finishYCord].type === GraphUnitTypes.NODE) {\n    retGraph[finishXcord][finishYCord].type = GraphUnitTypes.FINISH;\n  } else {\n    throw new Error(\"The finish node coordinate is not a valid node\");\n  }\n\n  return retGraph;\n};\n\n//helper function that generates a node based on a paterrn in order to get the graph / edge ratio that I want in the shape I want\nconst generateGraphNode = (row: number, col: number) => {\n  //if row is even\n  if (row % 2 === 0) {\n    if (col % 2 === 0) {\n      const theCords: NodeCords = [row, col];\n      return {\n        type: GraphUnitTypes.NODE,\n        queued: false,\n        visited: false,\n        cords: theCords,\n      };\n    } else {\n      const theCords: NodeCords = [row, col];\n      return {\n        type: GraphUnitTypes.LEFT_RIGHT_EDGE,\n        queued: false,\n        visited: false,\n        cords: theCords,\n      };\n    }\n  }\n  // if row is odd\n  else {\n    if (col % 2 === 0) {\n      const theCords: NodeCords = [row, col];\n      return {\n        type: GraphUnitTypes.UP_DOWN_EDGE,\n        queued: false,\n        visited: false,\n        cords: theCords,\n      };\n    } else {\n      const theCords: NodeCords = [row, col];\n      return {\n        type: GraphUnitTypes.EMPTY_SPACE,\n        queued: false,\n        visited: false,\n        cords: theCords,\n      };\n    }\n  }\n};\n\n//Generates the react representation from the code representation of the matrix graph\nconst renderGraph = (\n  graph: GraphType,\n  setGraph: React.Dispatch<React.SetStateAction<GraphType>>\n) => {\n  return (\n    <>\n      {\" \"}\n      {graph.map((row, i) => {\n        return (\n          <div className=\"graph-col\" key={i}>\n            {row.map((item, j) => {\n              return (\n                <GraphNode\n                  GraphNode={item}\n                  setGraph={setGraph}\n                  Graph={graph}\n                  key={i + j}\n                />\n              );\n            })}\n          </div>\n        );\n      })}{\" \"}\n    </>\n  );\n};\n\n//The actual functional compoenet that renders the graph as a whole with buttons\nconst GraphComponent = () => {\n  const startNodeRef = useRef(START_NODE_CORDS);\n  const finishNodeRef = useRef(FINISH_NODE_CORDS);\n  const [Graph, SetGraph] = useState(\n    generateGraph(\n      startNodeRef.current,\n      finishNodeRef.current,\n      GRAPH_HEIGHT,\n      GRAPH_WIDTH\n    )\n  );\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"100vh\",\n        flexDirection: \"column\",\n      }}\n      className=\"graph_meta_container\"\n    >\n      <div style={{}} className=\"graph_container\">\n        {renderGraph(Graph, SetGraph)}\n      </div>\n      <OptionsBar\n        Graph={Graph}\n        SetGraph={SetGraph}\n        GRAPH_HEIGHT={GRAPH_HEIGHT}\n        GRAPH_WIDTH={GRAPH_WIDTH}\n      />\n    </div>\n  );\n};\n\nexport default GraphComponent;\n","import React from 'react';\nimport './css/App.css';\nimport Graph from './components/Graph';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Graph></Graph>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}